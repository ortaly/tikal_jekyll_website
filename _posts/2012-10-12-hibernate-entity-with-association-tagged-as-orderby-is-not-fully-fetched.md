---
layout: post
title: Hibernate entity with association tagged as @OrderBy is not fully fetched
created: 1350053398
author: roni
permalink: /java/hibernate-entity-association-tagged-orderby-not-fully-fetched
tags:
- JAVA
- OrderBy
- JPA
- Hibernate
- fetch
---
<p>Assume you have two entities <em>SuperEntity</em> and <em>SubEntity</em> that has one to many bi-directional association.</p>
<p>The one to many association is eagerly fetched and also defined with the <em>@OrderBy</em> jpa annotation.</p>
<p>When trying to load the <em>SuperEntity</em>,&nbsp;we expect the entity contains a list of <em>SubEntity</em>s sorted according to the field defined in the order by annotation.</p>
<p>In fact the list retrieved unordered. Moreover the sql generated by Hibernate framework includes only select query for the <em>SuperEntity</em> without any reference to the <em>SubEntity </em>or to order by. The generated sql suppose to have select query with a join or two select queries for both tables with the order by clause.</p>
<p>Lets go to a code example:</p>
<p><strong>SuperEntity</strong><strong> Class:</strong></p>
<pre title="code" class="brush: java;highlight: [4,5,6]; ">
@Entity
@Table(name = &quot;SuperEntity&quot;)
public class SuperEntity {
	public SuperEntity() {
		super();
	}

	@Id
	private long id;

	@OneToMany(mappedBy = &quot;superEntity&quot;, cascade = CascadeType.ALL, fetch = FetchType.EAGER)
	@OrderBy(&quot;priority&quot;)
	List&lt;SubEntity&gt; subEntities;

	public List&lt;SubEntity&gt; getSubEntities() {
		return subEntities;
	}

	public void setSubEntities(List&lt;SubEntity&gt; subEntities) {
		this.subEntities = subEntities;
	}

	public SuperEntity(long id, List&lt;SubEntity&gt; subEntities) {
		super();
		this.id = id;
		this.subEntities = subEntities;
	}

	@Override
	public String toString() {
		return &quot;SuperEntity [id=&quot; + id + &quot;, inputProfileTransmitDatas=&quot; + subEntities + &quot;]&quot;;
	}

}
</pre>
<p><strong>SubEntity</strong><strong> Class:</strong></p>
<pre class="brush: java;highlight: [27,28,29]; " title="code">
@Entity
@Table(name = &quot;SubEntity&quot;)
public class SubEntity {
	@Id
	private long id;

	@Column(name = &quot;PRIORITY&quot;)
	Integer priority;

	@ManyToOne
	@JoinColumn(name = &quot;SuperEntity_ID&quot;)
	SuperEntity superEntity;

	public SuperEntity getSuperEntity() {
		return superEntity;
	}

	@Override
	public String toString() {
		return &quot;SubEntity [id=&quot; + id + &quot;, priority=&quot; + priority + &quot;]&quot;;
	}

	public void setSuperEntity(SuperEntity superEntity) {
		this.superEntity = superEntity;
	}

	public SubEntity() {
		super();
	}

	public SubEntity(long id, Integer priority) {
		super();
		this.id = id;
		this.priority = priority;
	}
}
</pre>
<p><strong>Query Method:</strong></p>
<pre class="brush: java;highlight: [17]; " title="code">
	public void query() {
		Session session = sessionFactory.getCurrentSession();
		SubEntity subEntity2 = new SubEntity(2, 2);
		SubEntity subEntity1 = new SubEntity(1, 1);
		List&lt;SubEntity&gt; inputTransmitList = new ArrayList&lt;SubEntity&gt;();
		inputTransmitList.add(subEntity2);
		inputTransmitList.add(subEntity1);
		SuperEntity superEntity = new SuperEntity(1, inputTransmitList);
		subEntity1.setSuperEntity(superEntity);
		subEntity2.setSuperEntity(superEntity);
		
		session.beginTransaction();
		session.save(superEntity);
		session.save(subEntity2);
		session.save(subEntity1);
		session.getTransaction().commit();
		session.close();

		session = sessionFactory.getCurrentSession();
		session.beginTransaction();
		Query query = session.createQuery(&quot;from SuperEntity&quot;);
		List&lt;SuperEntity&gt; result = query.list();
		System.out.println(result.get(0).getSubEntities());
		session.getTransaction().commit();
	}</pre>
<p>Hibernate might sometimes generates the following sql for the hql query above:</p>
<pre class="brush: sql;" title="code">
select superentit0_.id as id19_ from super_entity superentit0_
</pre>
<p>The results for this sql are of course unordered:</p>
<pre class="brush: sql;" title="code">
[SubEntity [id=2, priority=2], SubEntity [id=1, priority=1]]
</pre>
<p>There are two things that when done can improve your mood:</p>
<ol>
    <li>Taking care to define default constructors for the entities.</li>
    <li>Making sure to close the previous Hibernate session. Sometimes the Hibernate framework uses the cache of the session to retrieve part of the hql results like in the case above. To make sure Hibernate framework will turn to the database you should close previous sessions.</li>
</ol>
<p>Now after adding these items (marked in the code) the generated sql is as expected:</p>
<pre class="brush: sql;" title="code">
select superentit0_.id as id19_ from super_entity superentit0_
select subentitie0_.super_entity_id as super3_19_1_, subentitie0_.id as id1_, subentitie0_.id as id18_0_, subentitie0_.priority as priority18_0_, subentitie0_.super_entity_id as super3_18_0_ from sub_entity subentitie0_ where subentitie0_.super_entity_id=? order by subentitie0_.priority asc</pre>
<p>The results are ordered as well:</p>
<pre class="brush: sql;" title="code">
[SubEntity [id=1, priority=1], SubEntity [id=2, priority=2]]</pre>
<p>&nbsp;</p>
