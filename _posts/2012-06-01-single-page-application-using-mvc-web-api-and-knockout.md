---
layout: post
title: Single Page Application using MVC, Web API & knockout
created: 1338557438
author: menny
permalink: /single-page-application-using-mvc-web-api-knockout
tags:
- .NET
---
<p>This is the first post in a series about Tikal’s fuse day session “Building Single Page Application with knockout and <a href="http://ASP.NET">ASP.NET</a> <a href="http://www.asp.net/mvc/mvc4">MVC 4</a>”. If you have already installed the new <a href="http://www.asp.net/mvc/mvc4">MVC 4</a> you can see there is a template solution called <a href="http://channel9.msdn.com/Events/TechDays/Techdays-2012-the-Netherlands/2159">“SPA” (Single Page Application)</a>. This SPA application is used with conjunction of Web API (new to <a href="http://www.asp.net/mvc/mvc4">MVC 4</a>) and on top of upshot.JS, knockout and nav.js. upshot.JS is a new micro framework from Microsoft that ease the interpretation between C# and JS, and since I wanted to stick to current open source technologies and maybe later not relay on a windows server (and IIS for that matter) I decided to do it with just knockout. I already <a href="http://www.onemenny.com/blog/javascript-frameworks-and-knockout/">talked</a> about knockout and why it’s my preferred binding solution.
<p>What I’m going to explain here is the basic architecture for the application. The solution is composed of 4 projects. I’ll walk through each of them from the simplest to the real deal.
<p><a href="http://www.onemenny.com/blog/wp-content/uploads/2012/06/image.png"><img style="background-image: none; border-bottom: 0px; border-left: 0px; margin: 0px 31px 0px 5px; padding-left: 0px; padding-right: 0px; display: inline; float: left; border-top: 0px; border-right: 0px; padding-top: 0px" title="image" border="0" alt="image" align="left" src="http://www.onemenny.com/blog/wp-content/uploads/2012/06/image_thumb.png" width="194" height="419"></a> <strong><u>The first project ReleaseIt</u></strong> is called after our demo company, and is the root for all the common functionality and tools we are going to use. For that matter it’s the same as System.dll assembly. And if we want to write helpers for XML serialization, will place them under ReleaseIt.Xml.Serialization. If the serialization folder will become too large, we’ll then split the folder into a new assembly called ReleaseIt.XML. So far the regular stuff, but just to make the things super clear I’m going over the basics here again.
<p><b></b> 
<p><b></b> 
<p><b></b> 
<p><b></b> 
<p><strong><u>The second project ReleaseIt.Web</u>.</strong> Since we are writing a web application we’ll put all the web helpers in this assembly, just like the ReleaseIt assembly for general (system) stuff, here we’ll locate the web classes sticking to the same convention. In this assembly we’ll have the MVC folder for MVC extensions.
<p><a href="http://www.onemenny.com/blog/wp-content/uploads/2012/06/image1.png"><img style="background-image: none; border-bottom: 0px; border-left: 0px; margin: 0px 18px 0px 0px; padding-left: 0px; padding-right: 0px; display: inline; float: left; border-top: 0px; border-right: 0px; padding-top: 0px" title="image" border="0" alt="image" align="left" src="http://www.onemenny.com/blog/wp-content/uploads/2012/06/image_thumb1.png" width="350" height="164"></a>And in our case, the extensions to wire up the <a href="http://www.onemenny.com/blog/mvc-4-beta-registertemplatebundles-and-enabledefaultbundles/">bundling</a> in our application. So whenever we are in debug mode we want our JS files to be exactly as we wrote them: a separate file for each module or component that when put together – builds our entire application. But we still want them as separate files so it will be easy to debug when using the browsers developer tools. On release we want the opposite. We want all the files to bundle into a single file and go over minification process. In that way the browser will only execute 1 request for our entire JS app, instead of multiple requests for each JS module.
<p>Now this is a philosophy of decision making. You can decide if you want to load your entire application as a single file when the user starts the application (much like Gmail), or load only the necessary files and later load asynchronously the rest of the needed files (<a href="http://engineering.twitter.com/2012/05/improving-performance-on-twittercom.html">like twitter is doing now</a>).
<p>There is one more important issue when bundling all your JS file: the order in which they are bundle. This can be a tricky situation if one module is dependent on others. The common solution is to use the <a href="file:///C:\Users\Onemenny\AppData\Roaming\Microsoft\Word\commonjs.org\">CommonJS</a> modules approach. The basics of this approach is that each module declares what are the other modules it depends on, and later a tool like <a href="http://requirejs.org/docs/commonjs.html">require.js</a> can be used to make sure a particular module requirements are fully fulfilled.
<p>In our case the situation is very simple so we only iterated between the JS files and concatenated them into a single file. Much like the <a href="http://blog.kurtschindler.net/post/disabling-bundling-and-minification-in-aspnet-45mvc-4">approach seen on this blog</a> for CSS.
<p><a href="http://www.onemenny.com/blog/wp-content/uploads/2012/06/image2.png"><strong><img style="background-image: none; border-bottom: 0px; border-left: 0px; margin: 0px 12px 0px 0px; padding-left: 0px; padding-right: 0px; display: inline; float: left; border-top: 0px; border-right: 0px; padding-top: 0px" title="image" border="0" alt="image" align="left" src="http://www.onemenny.com/blog/wp-content/uploads/2012/06/image_thumb2.png" width="283" height="324"></strong></a><u><strong>The third and fourth projects</strong></u> are basically the DAL implemented with a repository pattern: ReleaseIt.Repository is where all our interfaces and entities lie (much like a contract DLL in WCF), while the other project ReleaseIt.Repository.EF is the EntityFramework implementation of these contracts.
<p>The hard wiring is done via <a href="http://msdn.microsoft.com/en-us/library/dd460648.aspx">MEF</a>. It just was the simplest DI container for this job. So our DataProviders in the EF implementation declares an export <a href="http://www.onemenny.com/blog/wp-content/uploads/2012/06/clip_image008.png"><img style="background-image: none; border-bottom: 0px; border-left: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top: 0px; border-right: 0px; padding-top: 0px" title="clip_image008" border="0" alt="clip_image008" src="http://www.onemenny.com/blog/wp-content/uploads/2012/06/clip_image008_thumb.png" width="467" height="140"></a></p>
<p>then, in the build events of the EF project we copy the output DLL to our main application’s bin folder, and on the global.ascx (our main app) we tell MEF to initiate with this assembly <a href="http://www.onemenny.com/blog/wp-content/uploads/2012/06/image3.png"><img style="background-image: none; border-bottom: 0px; border-left: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top: 0px; border-right: 0px; padding-top: 0px" title="image" border="0" alt="image" src="http://www.onemenny.com/blog/wp-content/uploads/2012/06/image_thumb3.png" width="569" height="263"></a> </p>
<p>what we should have done is to register our DI container with MVC, or use MVC service locator. But then again, this was faster. </p>
<h2><u>The main project</u></h2>
<p>The main project is really just a regular MVC project with a few manipulations. I’ll go over each folder and explain:
<ul>
<li><strong>Content</strong> – the CSS, media and stuff</li>
<li><strong>Controllers</strong> – the MVC controllers. Here we only have 1 controller to serve our only page in the application. <a href="http://www.onemenny.com/blog/wp-content/uploads/2012/06/image4.png"><img style="background-image: none; border-bottom: 0px; border-left: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top: 0px; border-right: 0px; padding-top: 0px" title="image" border="0" alt="image" src="http://www.onemenny.com/blog/wp-content/uploads/2012/06/image_thumb4.png" width="569" height="141"></a></li>
<ul>
<li>Underneath it we have an <strong>API</strong> folder for all our Web API. Each controller will inherit from ApiController and use MEF to get the proper provider </li>
</ul>
</ul>
<p><a href="http://www.onemenny.com/blog/wp-content/uploads/2012/06/image5.png"><img style="background-image: none; border-bottom: 0px; border-left: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top: 0px; border-right: 0px; padding-top: 0px" title="image" border="0" alt="image" src="http://www.onemenny.com/blog/wp-content/uploads/2012/06/image_thumb5.png" width="569" height="449"></a></p>
<p>If you are not familiar with MEF or DI or Ioc, I suggest you read about these supper cools approaches. In most cases, because our DLL’s don’t have references to each other cause we are using MEF, the <u>compilation time will reduce in half </u>+ we get loosely coupled components. </p>
<ul>
<li>The <strong>Scripts</strong> folder is where all our JS Script are (I used NuGet for all the scripts packages) like JQuery and alike. </li>
<li><strong>JS</strong> folder is where our application located. We have controllers and viewModels that serve each view in the application. All our modules are implement with the <a href="http://addyosmani.com/resources/essentialjsdesignpatterns/book/#modulepatternjavascript">module design pattern</a> </li>
</ul>
<p><a href="http://www.onemenny.com/blog/wp-content/uploads/2012/06/image6.png"><img style="background-image: none; border-bottom: 0px; border-left: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top: 0px; border-right: 0px; padding-top: 0px" title="image" border="0" alt="image" src="http://www.onemenny.com/blog/wp-content/uploads/2012/06/image_thumb6.png" width="560" height="333"></a></p>
<ul>
<li>The<strong> Views</strong> folder is the basic MVC views folder. I stripped it out of most of its content, since we only have 1 page in the application (Index.cshtml). The other file in the folder is _ViewStart.cshtml which is the code that executes before every view is rendered. <a href="http://www.onemenny.com/blog/wp-content/uploads/2012/06/image7.png"><img style="background-image: none; border-bottom: 0px; border-left: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top: 0px; border-right: 0px; padding-top: 0px" title="image" border="0" alt="image" src="http://www.onemenny.com/blog/wp-content/uploads/2012/06/image_thumb7.png" width="569" height="93"></a></li>
</ul>
<blockquote><p>Under the <strong>Shared</strong> folder we still have our _Layout.cshtml (the master page) and others alike (footer & header). By the way the convention for _XXX (underscore) is for partial views in MVC. </p>
</blockquote>
<ul>
<ul>
<li>Underneath the shared folder we have the <strong>Pagelayouts</strong> that we are going to use: each page can be composed of 1 or more templates. And of course the <strong>Templates</strong> folder for the, well, templates. </li>
</ul>
</ul>
<p>Well, that’s basically it; you can catch the main drift. On the next post I’ll go over the views and JS to explain how we composed our application so keep tuned.</p>
