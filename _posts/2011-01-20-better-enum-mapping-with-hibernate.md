---
layout: post
title: Better Enum Mapping with Hibernate
created: 1295515200
author: gabi
permalink: /better-enum-mapping-hibernate
---
JPA and Hibernate provides two ways to map enum fields to database fields: either map the enum value ordinal with @Enumerated(EnumType.ORDINAL) or the enum value name with @Enumerated(EnumType.STRING) . Both cases are not ideal, because it's very easy to make changes to the enum, such as changing values order or renaming values, and forgetting to migrate the existing values in the database accordingly. Actually the need to migrate existing data is not justified if you just want to change Java code.<br /><br />Here is a mechanism that lets you decouple the enum value names and ordinals from the data, while still making it easy to map enum fields to database columns.<br /><br />The solution can be specific to an enum type, but it would be better to have all your persistent enum types implement the same interface to reuse the mechanism. Let's define the PersistentEnum interface:<br /><br /><pre class="brush: java">public interface PersistentEnum {<br />    int getId();<br />}<br /></pre><br />and it will be implemented by enum types, for example:<br /><br /><pre class="brush: java">public enum Gender implements PersistentEnum {<br /><br />    MALE(0),<br />    FEMALE(1);<br /><br />    private final int id;<br /><br />    Gender(int id) {<br />        this.id = id<br />    }<br /><br />    @Override<br />    public int getId() {<br />        return id;<br />    }<br /><br />}<br /></pre><br />Now we need to define the Hibernate User Type that will do the conversion both ways. Each enum requires its own user type, so first we will code an abstract superclass that works with the PersistentEnum interface and then subclass it for each enum:<br /><br /><pre class="brush: java">public abstract class PersistentEnumUserType<T extends PersistentEnum> implements UserType {<br /><br />    @Override<br />    public Object assemble(Serializable cached, Object owner)<br />            throws HibernateException {<br />        return cached;<br />    }<br /><br />    @Override<br />    public Object deepCopy(Object value) throws HibernateException {<br />        return value;<br />    }<br /><br />    @Override<br />    public Serializable disassemble(Object value) throws HibernateException {<br />        return (Serializable)value;<br />    }<br /><br />    @Override<br />    public boolean equals(Object x, Object y) throws HibernateException {<br />        return x == y;<br />    }<br /><br />    @Override<br />    public int hashCode(Object x) throws HibernateException {<br />        return x == null ? 0 : x.hashCode();<br />    }<br /><br />    @Override<br />    public boolean isMutable() {<br />        return false;<br />    }<br /><br />    @Override<br />    public Object nullSafeGet(ResultSet rs, String[] names, Object owner)<br />            throws HibernateException, SQLException {<br />        int id = rs.getInt(names[0]);<br />        if(rs.wasNull()) {<br />            return null;<br />        }<br />        for(PersistentEnum value : returnedClass().getEnumConstants()) {<br />            if(id == value.getId()) {<br />                return value;<br />            }<br />        }<br />        throw new IllegalStateException("Unknown " + returnedClass().getSimpleName() + " id");<br />    }<br /><br />    @Override<br />    public void nullSafeSet(PreparedStatement st, Object value, int index)<br />            throws HibernateException, SQLException {<br />        if (value == null) {<br />            st.setNull(index, Types.INTEGER);<br />        } else {<br />            st.setInt(index, ((PersistentEnum)value).getId());<br />        }<br />    }<br /><br />    @Override<br />    public Object replace(Object original, Object target, Object owner)<br />            throws HibernateException {<br />        return original;<br />    }<br /><br />    @Override<br />    public abstract Class<T> returnedClass();<br /><br />    @Override<br />    public int[] sqlTypes() {<br />        return new int[]{Types.INTEGER};<br />    }<br /><br />}<br /></pre><br />The interesting methods are nullSafeGet() which is called when the resultset from the database is mapped to an object, and nullSafeSet() which is called when the fields of an object are mapped to SQL parameters of insert/update/delete statements.<br /><br />The extension point is the abstract method returnedClass() - in every subclass we will override it so it returns the specific enum class. A User Type for the Gender enum defined above would like this:<br /><br /><pre class="brush: java">public class GenderUserType extends PersistentEnumUserType<Gender> {<br /><br />    @Override<br />    public Class<Gender> returnedClass() {<br />        return Gender.class;<br />    }<br /><br />}<br /></pre><br />The last thing to do is to configure fields of enum types to use the appropriate user types:<br /><br /><pre class="brush: java">@Entity<br />public class Person {<br /><br />    @Type(type="it.recompile.GenderUserType")<br />    private Gender gender;<br /><br />    // other fields and methods...<br />}<br /></pre><br />Note that the type attribute should contain the fully qualified class of the user type, including the package.<br /><br />That's it - now you can safely make changes to your enum classes without worrying about problems with existing data, as long as you don't change the id values in the constructors (which you have no reason to do).
